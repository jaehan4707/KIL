# 문제 핵심
다른 DP 문제가 그러하듯이 DP 배열을 어떻게 설계하느냐가 가장 중요한 문제이다.  
비용으로 DP 배열을 잡아도 되고, 고객수로 DP 배열을 잡아도 된다.
1차원 배열과 2차원배열도 있지만, 되도록이면 1차원 배열로 할 수 있는 문제는 1차원 배열로 해결하는것이 좋다고 생각한다.  
나는 DP 배열을 다음과 같이 선언했다.
```text
DP[n]  -> n원을 사용해서 모을 수 있는 고객의 최대 수 
```
DP[1] -> 1원을 사용해서 모을 수 있는 고객의 최대 수  
DP[2] -> 2원을 사용해서 모을 수 있는 고객의 최대 수
....
DP[100] -> 100원을 사용해서 모을 수 있는 고객의 최대 수이다.


```kotlin
for(l in list){ //k명을 뽑는데 최소한의 비용을 결정하자.
    for(i in 0 until DP.size){ //i원을 사용해서 뽑을 수 있는 최대의 고객수를 결정하자
        if(i-l.first>=0){ //비용이 넘는다면
            DP[i] = max(DP[i],DP[i-l.first]+l.second) //다른도시와 비교
        }
    }
}
```
DP[i]는 i원을 사용해서 모을 수 있는 최대 고객수이다.
각 도시별로 탐색해서 현재 고객수를 유지하는것이 최선인지, 다른 도시에서 돈을 사용해서 고객을 모으는지 비교해야한다.
DP 배열에서 왜 빼야하냐면, 그 비용만큼 지금 끌어서 쓰기 때문에, 그 비용을 사용하기 전 상태와 비교하는것이다.

```kotlin
for(i in 0 until DP.size){
    if(DP[i]>=C){
        print(i)
        break
    }
}
```
C이상의 사람을 모으기 위한 최소한의 비용은 DP배열을 탐색하면서 처음으로 값이 C가 넘을때이다.
그때의 index가 최소 비용일 것이다.

